package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// SecurityRulePropertiesFormat security rule properties format
// swagger:model SecurityRulePropertiesFormat
type SecurityRulePropertiesFormat struct {

	// Gets or sets network traffic is allowed or denied. Possible values are 'Allow' and 'Deny'
	// Required: true
	Access *string `json:"access"`

	// Gets or sets a description for this rule. Restricted to 140 chars.
	Description string `json:"description,omitempty"`

	// Gets or sets destination address prefix. CIDR or source IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	// Required: true
	DestinationAddressPrefix *string `json:"destinationAddressPrefix"`

	// Gets or sets Destination Port or Range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
	DestinationPortRange string `json:"destinationPortRange,omitempty"`

	// Gets or sets the direction of the rule.InBound or Outbound. The direction specifies if rule will be evaluated on incoming or outcoming traffic.
	// Required: true
	Direction *string `json:"direction"`

	// Gets or sets the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority int32 `json:"priority,omitempty"`

	// Gets or sets Network protocol this rule applies to. Can be Tcp, Udp or All(*).
	// Required: true
	Protocol *string `json:"protocol"`

	// Gets or sets Provisioning state of the PublicIP resource Updating/Deleting/Failed
	ProvisioningState string `json:"provisioningState,omitempty"`

	// Gets or sets source address prefix. CIDR or source IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	// Required: true
	SourceAddressPrefix *string `json:"sourceAddressPrefix"`

	// Gets or sets Source Port or Range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
	SourcePortRange string `json:"sourcePortRange,omitempty"`
}

// Validate validates this security rule properties format
func (m *SecurityRulePropertiesFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccess(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDestinationAddressPrefix(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSourceAddressPrefix(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var securityRulePropertiesFormatTypeAccessPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Allow","Deny"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		securityRulePropertiesFormatTypeAccessPropEnum = append(securityRulePropertiesFormatTypeAccessPropEnum, v)
	}
}

const (
	// SecurityRulePropertiesFormatAccessAllow captures enum value "Allow"
	SecurityRulePropertiesFormatAccessAllow string = "Allow"
	// SecurityRulePropertiesFormatAccessDeny captures enum value "Deny"
	SecurityRulePropertiesFormatAccessDeny string = "Deny"
)

// prop value enum
func (m *SecurityRulePropertiesFormat) validateAccessEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, securityRulePropertiesFormatTypeAccessPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SecurityRulePropertiesFormat) validateAccess(formats strfmt.Registry) error {

	if err := validate.Required("access", "body", m.Access); err != nil {
		return err
	}

	// value enum
	if err := m.validateAccessEnum("access", "body", *m.Access); err != nil {
		return err
	}

	return nil
}

func (m *SecurityRulePropertiesFormat) validateDestinationAddressPrefix(formats strfmt.Registry) error {

	if err := validate.Required("destinationAddressPrefix", "body", m.DestinationAddressPrefix); err != nil {
		return err
	}

	return nil
}

var securityRulePropertiesFormatTypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Inbound","Outbound"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		securityRulePropertiesFormatTypeDirectionPropEnum = append(securityRulePropertiesFormatTypeDirectionPropEnum, v)
	}
}

const (
	// SecurityRulePropertiesFormatDirectionInbound captures enum value "Inbound"
	SecurityRulePropertiesFormatDirectionInbound string = "Inbound"
	// SecurityRulePropertiesFormatDirectionOutbound captures enum value "Outbound"
	SecurityRulePropertiesFormatDirectionOutbound string = "Outbound"
)

// prop value enum
func (m *SecurityRulePropertiesFormat) validateDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, securityRulePropertiesFormatTypeDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SecurityRulePropertiesFormat) validateDirection(formats strfmt.Registry) error {

	if err := validate.Required("direction", "body", m.Direction); err != nil {
		return err
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", *m.Direction); err != nil {
		return err
	}

	return nil
}

var securityRulePropertiesFormatTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Tcp","Udp","*"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		securityRulePropertiesFormatTypeProtocolPropEnum = append(securityRulePropertiesFormatTypeProtocolPropEnum, v)
	}
}

const (
	// SecurityRulePropertiesFormatProtocolTCP captures enum value "Tcp"
	SecurityRulePropertiesFormatProtocolTCP string = "Tcp"
	// SecurityRulePropertiesFormatProtocolUDP captures enum value "Udp"
	SecurityRulePropertiesFormatProtocolUDP string = "Udp"
	// SecurityRulePropertiesFormatProtocolNr captures enum value "*"
	SecurityRulePropertiesFormatProtocolNr string = "*"
)

// prop value enum
func (m *SecurityRulePropertiesFormat) validateProtocolEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, securityRulePropertiesFormatTypeProtocolPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SecurityRulePropertiesFormat) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *SecurityRulePropertiesFormat) validateSourceAddressPrefix(formats strfmt.Registry) error {

	if err := validate.Required("sourceAddressPrefix", "body", m.SourceAddressPrefix); err != nil {
		return err
	}

	return nil
}

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// ApplicationGatewayPropertiesFormat Properties of Application Gateway
// swagger:model ApplicationGatewayPropertiesFormat
type ApplicationGatewayPropertiesFormat struct {

	// Gets or sets backend address pool of application gateway resource
	BackendAddressPools []*ApplicationGatewayBackendAddressPool `json:"backendAddressPools"`

	// Gets or sets backend http settings of application gateway resource
	BackendHTTPSettingsCollection []*ApplicationGatewayBackendHTTPSettings `json:"backendHttpSettingsCollection"`

	// Gets or sets frontend IP addresses of application gateway resource
	FrontendIPConfigurations []*ApplicationGatewayFrontendIPConfiguration `json:"frontendIPConfigurations"`

	// Gets or sets frontend ports of application gateway resource
	FrontendPorts []*ApplicationGatewayFrontendPort `json:"frontendPorts"`

	// Gets or sets subnets of application gateway resource
	GatewayIPConfigurations []*ApplicationGatewayIPConfiguration `json:"gatewayIPConfigurations"`

	// Gets or sets HTTP listeners of application gateway resource
	HTTPListeners []*ApplicationGatewayHTTPListener `json:"httpListeners"`

	// Gets operational state of application gateway resource
	// Read Only: true
	OperationalState string `json:"operationalState,omitempty"`

	// Gets or sets probes of application gateway resource
	Probes []*ApplicationGatewayProbe `json:"probes"`

	// Gets or sets Provisioning state of the ApplicationGateway resource Updating/Deleting/Failed
	ProvisioningState string `json:"provisioningState,omitempty"`

	// Gets or sets request routing rules of application gateway resource
	RequestRoutingRules []*ApplicationGatewayRequestRoutingRule `json:"requestRoutingRules"`

	// Gets or sets resource guid property of the ApplicationGateway resource
	ResourceGUID string `json:"resourceGuid,omitempty"`

	// Gets or sets sku of application gateway resource
	Sku *ApplicationGatewaySku `json:"sku,omitempty"`

	// Gets or sets ssl certificates of application gateway resource
	SslCertificates []*ApplicationGatewaySslCertificate `json:"sslCertificates"`

	// Gets or sets URL path map of application gateway resource
	URLPathMaps []*ApplicationGatewayURLPathMap `json:"urlPathMaps"`
}

// Validate validates this application gateway properties format
func (m *ApplicationGatewayPropertiesFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackendAddressPools(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBackendHTTPSettingsCollection(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFrontendIPConfigurations(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFrontendPorts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateGatewayIPConfigurations(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHTTPListeners(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProbes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRequestRoutingRules(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSku(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSslCertificates(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateURLPathMaps(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateBackendAddressPools(formats strfmt.Registry) error {

	if swag.IsZero(m.BackendAddressPools) { // not required
		return nil
	}

	for i := 0; i < len(m.BackendAddressPools); i++ {

		if swag.IsZero(m.BackendAddressPools[i]) { // not required
			continue
		}

		if m.BackendAddressPools[i] != nil {

			if err := m.BackendAddressPools[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateBackendHTTPSettingsCollection(formats strfmt.Registry) error {

	if swag.IsZero(m.BackendHTTPSettingsCollection) { // not required
		return nil
	}

	for i := 0; i < len(m.BackendHTTPSettingsCollection); i++ {

		if swag.IsZero(m.BackendHTTPSettingsCollection[i]) { // not required
			continue
		}

		if m.BackendHTTPSettingsCollection[i] != nil {

			if err := m.BackendHTTPSettingsCollection[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateFrontendIPConfigurations(formats strfmt.Registry) error {

	if swag.IsZero(m.FrontendIPConfigurations) { // not required
		return nil
	}

	for i := 0; i < len(m.FrontendIPConfigurations); i++ {

		if swag.IsZero(m.FrontendIPConfigurations[i]) { // not required
			continue
		}

		if m.FrontendIPConfigurations[i] != nil {

			if err := m.FrontendIPConfigurations[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateFrontendPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.FrontendPorts) { // not required
		return nil
	}

	for i := 0; i < len(m.FrontendPorts); i++ {

		if swag.IsZero(m.FrontendPorts[i]) { // not required
			continue
		}

		if m.FrontendPorts[i] != nil {

			if err := m.FrontendPorts[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateGatewayIPConfigurations(formats strfmt.Registry) error {

	if swag.IsZero(m.GatewayIPConfigurations) { // not required
		return nil
	}

	for i := 0; i < len(m.GatewayIPConfigurations); i++ {

		if swag.IsZero(m.GatewayIPConfigurations[i]) { // not required
			continue
		}

		if m.GatewayIPConfigurations[i] != nil {

			if err := m.GatewayIPConfigurations[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateHTTPListeners(formats strfmt.Registry) error {

	if swag.IsZero(m.HTTPListeners) { // not required
		return nil
	}

	for i := 0; i < len(m.HTTPListeners); i++ {

		if swag.IsZero(m.HTTPListeners[i]) { // not required
			continue
		}

		if m.HTTPListeners[i] != nil {

			if err := m.HTTPListeners[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var applicationGatewayPropertiesFormatTypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Stopped","Starting","Running","Stopping"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationGatewayPropertiesFormatTypeOperationalStatePropEnum = append(applicationGatewayPropertiesFormatTypeOperationalStatePropEnum, v)
	}
}

const (
	// ApplicationGatewayPropertiesFormatOperationalStateStopped captures enum value "Stopped"
	ApplicationGatewayPropertiesFormatOperationalStateStopped string = "Stopped"
	// ApplicationGatewayPropertiesFormatOperationalStateStarting captures enum value "Starting"
	ApplicationGatewayPropertiesFormatOperationalStateStarting string = "Starting"
	// ApplicationGatewayPropertiesFormatOperationalStateRunning captures enum value "Running"
	ApplicationGatewayPropertiesFormatOperationalStateRunning string = "Running"
	// ApplicationGatewayPropertiesFormatOperationalStateStopping captures enum value "Stopping"
	ApplicationGatewayPropertiesFormatOperationalStateStopping string = "Stopping"
)

// prop value enum
func (m *ApplicationGatewayPropertiesFormat) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, applicationGatewayPropertiesFormatTypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operationalState", "body", m.OperationalState); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateProbes(formats strfmt.Registry) error {

	if swag.IsZero(m.Probes) { // not required
		return nil
	}

	for i := 0; i < len(m.Probes); i++ {

		if swag.IsZero(m.Probes[i]) { // not required
			continue
		}

		if m.Probes[i] != nil {

			if err := m.Probes[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateRequestRoutingRules(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestRoutingRules) { // not required
		return nil
	}

	for i := 0; i < len(m.RequestRoutingRules); i++ {

		if swag.IsZero(m.RequestRoutingRules[i]) { // not required
			continue
		}

		if m.RequestRoutingRules[i] != nil {

			if err := m.RequestRoutingRules[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateSku(formats strfmt.Registry) error {

	if swag.IsZero(m.Sku) { // not required
		return nil
	}

	if m.Sku != nil {

		if err := m.Sku.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateSslCertificates(formats strfmt.Registry) error {

	if swag.IsZero(m.SslCertificates) { // not required
		return nil
	}

	for i := 0; i < len(m.SslCertificates); i++ {

		if swag.IsZero(m.SslCertificates[i]) { // not required
			continue
		}

		if m.SslCertificates[i] != nil {

			if err := m.SslCertificates[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationGatewayPropertiesFormat) validateURLPathMaps(formats strfmt.Registry) error {

	if swag.IsZero(m.URLPathMaps) { // not required
		return nil
	}

	for i := 0; i < len(m.URLPathMaps); i++ {

		if swag.IsZero(m.URLPathMaps[i]) { // not required
			continue
		}

		if m.URLPathMaps[i] != nil {

			if err := m.URLPathMaps[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// FrontendIPConfigurationPropertiesFormat Properties of Frontend IP Configuration of the load balancer
// swagger:model FrontendIPConfigurationPropertiesFormat
type FrontendIPConfigurationPropertiesFormat struct {

	// Read only.Inbound pools URIs that use this frontend IP
	InboundNatPools []*SubResource `json:"inboundNatPools"`

	// Read only.Inbound rules URIs that use this frontend IP
	InboundNatRules []*SubResource `json:"inboundNatRules"`

	// Gets Load Balancing rules URIs that use this frontend IP
	LoadBalancingRules []*SubResource `json:"loadBalancingRules"`

	// Read only.Outbound rules URIs that use this frontend IP
	OutboundNatRules []*SubResource `json:"outboundNatRules"`

	// Gets or sets the privateIPAddress of the IP Configuration
	PrivateIPAddress string `json:"privateIPAddress,omitempty"`

	// Gets or sets PrivateIP allocation method (Static/Dynamic)
	PrivateIPAllocationMethod string `json:"privateIPAllocationMethod,omitempty"`

	// Gets or sets Provisioning state of the PublicIP resource Updating/Deleting/Failed
	ProvisioningState string `json:"provisioningState,omitempty"`

	// Gets or sets the reference of the PublicIP resource
	PublicIPAddress *PublicIPAddress `json:"publicIPAddress,omitempty"`

	// Gets or sets the reference of the subnet resource
	Subnet *Subnet `json:"subnet,omitempty"`
}

// Validate validates this frontend IP configuration properties format
func (m *FrontendIPConfigurationPropertiesFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInboundNatPools(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateInboundNatRules(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLoadBalancingRules(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateOutboundNatRules(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePrivateIPAllocationMethod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePublicIPAddress(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSubnet(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FrontendIPConfigurationPropertiesFormat) validateInboundNatPools(formats strfmt.Registry) error {

	if swag.IsZero(m.InboundNatPools) { // not required
		return nil
	}

	for i := 0; i < len(m.InboundNatPools); i++ {

		if swag.IsZero(m.InboundNatPools[i]) { // not required
			continue
		}

		if m.InboundNatPools[i] != nil {

			if err := m.InboundNatPools[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *FrontendIPConfigurationPropertiesFormat) validateInboundNatRules(formats strfmt.Registry) error {

	if swag.IsZero(m.InboundNatRules) { // not required
		return nil
	}

	for i := 0; i < len(m.InboundNatRules); i++ {

		if swag.IsZero(m.InboundNatRules[i]) { // not required
			continue
		}

		if m.InboundNatRules[i] != nil {

			if err := m.InboundNatRules[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *FrontendIPConfigurationPropertiesFormat) validateLoadBalancingRules(formats strfmt.Registry) error {

	if swag.IsZero(m.LoadBalancingRules) { // not required
		return nil
	}

	for i := 0; i < len(m.LoadBalancingRules); i++ {

		if swag.IsZero(m.LoadBalancingRules[i]) { // not required
			continue
		}

		if m.LoadBalancingRules[i] != nil {

			if err := m.LoadBalancingRules[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *FrontendIPConfigurationPropertiesFormat) validateOutboundNatRules(formats strfmt.Registry) error {

	if swag.IsZero(m.OutboundNatRules) { // not required
		return nil
	}

	for i := 0; i < len(m.OutboundNatRules); i++ {

		if swag.IsZero(m.OutboundNatRules[i]) { // not required
			continue
		}

		if m.OutboundNatRules[i] != nil {

			if err := m.OutboundNatRules[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var frontendIpConfigurationPropertiesFormatTypePrivateIPAllocationMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Static","Dynamic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		frontendIpConfigurationPropertiesFormatTypePrivateIPAllocationMethodPropEnum = append(frontendIpConfigurationPropertiesFormatTypePrivateIPAllocationMethodPropEnum, v)
	}
}

const (
	// FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodStatic captures enum value "Static"
	FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodStatic string = "Static"
	// FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodDynamic captures enum value "Dynamic"
	FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodDynamic string = "Dynamic"
)

// prop value enum
func (m *FrontendIPConfigurationPropertiesFormat) validatePrivateIPAllocationMethodEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, frontendIpConfigurationPropertiesFormatTypePrivateIPAllocationMethodPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *FrontendIPConfigurationPropertiesFormat) validatePrivateIPAllocationMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.PrivateIPAllocationMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validatePrivateIPAllocationMethodEnum("privateIPAllocationMethod", "body", m.PrivateIPAllocationMethod); err != nil {
		return err
	}

	return nil
}

func (m *FrontendIPConfigurationPropertiesFormat) validatePublicIPAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.PublicIPAddress) { // not required
		return nil
	}

	if m.PublicIPAddress != nil {

		if err := m.PublicIPAddress.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *FrontendIPConfigurationPropertiesFormat) validateSubnet(formats strfmt.Registry) error {

	if swag.IsZero(m.Subnet) { // not required
		return nil
	}

	if m.Subnet != nil {

		if err := m.Subnet.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

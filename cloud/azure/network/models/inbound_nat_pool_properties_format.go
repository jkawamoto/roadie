package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// InboundNatPoolPropertiesFormat Properties of Inbound NAT pool
// swagger:model InboundNatPoolPropertiesFormat
type InboundNatPoolPropertiesFormat struct {

	// Gets or sets a port used for internal connections on the endpoint. The localPort attribute maps the eternal port of the endpoint to an internal port on a role. This is useful in scenarios where a role must communicate to an internal compotnent on a port that is different from the one that is exposed externally. If not specified, the value of localPort is the same as the port attribute. Set the value of localPort to '*' to automatically assign an unallocated port that is discoverable using the runtime API
	// Required: true
	BackendPort *int32 `json:"backendPort"`

	// Gets or sets a reference to frontend IP Addresses
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// Gets or sets the ending port range for the NAT pool. You can spcify any port number you choose, but the port numbers specified for each role in the service must be unique. Possible values range between 1 and 65535, inclusive
	// Required: true
	FrontendPortRangeEnd *int32 `json:"frontendPortRangeEnd"`

	// Gets or sets the starting port range for the NAT pool. You can spcify any port number you choose, but the port numbers specified for each role in the service must be unique. Possible values range between 1 and 65535, inclusive
	// Required: true
	FrontendPortRangeStart *int32 `json:"frontendPortRangeStart"`

	// Gets or sets the transport potocol for the external endpoint. Possible values are Udp or Tcp
	// Required: true
	Protocol *string `json:"protocol"`

	// Gets or sets Provisioning state of the PublicIP resource Updating/Deleting/Failed
	ProvisioningState string `json:"provisioningState,omitempty"`
}

// Validate validates this inbound nat pool properties format
func (m *InboundNatPoolPropertiesFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackendPort(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFrontendIPConfiguration(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFrontendPortRangeEnd(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFrontendPortRangeStart(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InboundNatPoolPropertiesFormat) validateBackendPort(formats strfmt.Registry) error {

	if err := validate.Required("backendPort", "body", m.BackendPort); err != nil {
		return err
	}

	return nil
}

func (m *InboundNatPoolPropertiesFormat) validateFrontendIPConfiguration(formats strfmt.Registry) error {

	if swag.IsZero(m.FrontendIPConfiguration) { // not required
		return nil
	}

	if m.FrontendIPConfiguration != nil {

		if err := m.FrontendIPConfiguration.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *InboundNatPoolPropertiesFormat) validateFrontendPortRangeEnd(formats strfmt.Registry) error {

	if err := validate.Required("frontendPortRangeEnd", "body", m.FrontendPortRangeEnd); err != nil {
		return err
	}

	return nil
}

func (m *InboundNatPoolPropertiesFormat) validateFrontendPortRangeStart(formats strfmt.Registry) error {

	if err := validate.Required("frontendPortRangeStart", "body", m.FrontendPortRangeStart); err != nil {
		return err
	}

	return nil
}

var inboundNatPoolPropertiesFormatTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Udp","Tcp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		inboundNatPoolPropertiesFormatTypeProtocolPropEnum = append(inboundNatPoolPropertiesFormatTypeProtocolPropEnum, v)
	}
}

const (
	// InboundNatPoolPropertiesFormatProtocolUDP captures enum value "Udp"
	InboundNatPoolPropertiesFormatProtocolUDP string = "Udp"
	// InboundNatPoolPropertiesFormatProtocolTCP captures enum value "Tcp"
	InboundNatPoolPropertiesFormatProtocolTCP string = "Tcp"
)

// prop value enum
func (m *InboundNatPoolPropertiesFormat) validateProtocolEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, inboundNatPoolPropertiesFormatTypeProtocolPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *InboundNatPoolPropertiesFormat) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// ProbePropertiesFormat probe properties format
// swagger:model ProbePropertiesFormat
type ProbePropertiesFormat struct {

	// Gets or sets the interval, in seconds, for how frequently to probe the endpoint for health status. Typically, the interval is slightly less than half the allocated timeout period (in seconds) which allows two full probes before taking the instance out of rotation. The default value is 15, the minimum value is 5
	IntervalInSeconds int32 `json:"intervalInSeconds,omitempty"`

	// Gets Load balancer rules that use this probe
	LoadBalancingRules []*SubResource `json:"loadBalancingRules"`

	// Gets or sets the number of probes where if no response, will result in stopping further traffic from being delivered to the endpoint. This values allows endponints to be taken out of rotation faster or slower than the typical times used in Azure.
	NumberOfProbes int32 `json:"numberOfProbes,omitempty"`

	// Gets or sets Port for communicating the probe. Possible values range from 1 to 65535, inclusive.
	// Required: true
	Port *int32 `json:"port"`

	// Gets or sets the protocol of the end point. Possible values are http pr Tcp. If Tcp is specified, a received ACK is required for the probe to be successful. If http is specified,a 200 OK response from the specifies URI is required for the probe to be successful
	// Required: true
	Protocol *string `json:"protocol"`

	// Gets or sets Provisioning state of the PublicIP resource Updating/Deleting/Failed
	ProvisioningState string `json:"provisioningState,omitempty"`

	// Gets or sets the URI used for requesting health status from the VM. Path is required if a protocol is set to http. Otherwise, it is not allowed. There is no default value
	RequestPath string `json:"requestPath,omitempty"`
}

// Validate validates this probe properties format
func (m *ProbePropertiesFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLoadBalancingRules(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProbePropertiesFormat) validateLoadBalancingRules(formats strfmt.Registry) error {

	if swag.IsZero(m.LoadBalancingRules) { // not required
		return nil
	}

	for i := 0; i < len(m.LoadBalancingRules); i++ {

		if swag.IsZero(m.LoadBalancingRules[i]) { // not required
			continue
		}

		if m.LoadBalancingRules[i] != nil {

			if err := m.LoadBalancingRules[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ProbePropertiesFormat) validatePort(formats strfmt.Registry) error {

	if err := validate.Required("port", "body", m.Port); err != nil {
		return err
	}

	return nil
}

var probePropertiesFormatTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Http","Tcp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		probePropertiesFormatTypeProtocolPropEnum = append(probePropertiesFormatTypeProtocolPropEnum, v)
	}
}

const (
	// ProbePropertiesFormatProtocolHTTP captures enum value "Http"
	ProbePropertiesFormatProtocolHTTP string = "Http"
	// ProbePropertiesFormatProtocolTCP captures enum value "Tcp"
	ProbePropertiesFormatProtocolTCP string = "Tcp"
)

// prop value enum
func (m *ProbePropertiesFormat) validateProtocolEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, probePropertiesFormatTypeProtocolPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProbePropertiesFormat) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

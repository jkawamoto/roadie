package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StorageAccountProperties Properties of the storage account.
// swagger:model StorageAccountProperties
type StorageAccountProperties struct {

	// Required for storage accounts where kind = BlobStorage. The access tier used for billing.
	// Read Only: true
	AccessTier string `json:"accessTier,omitempty"`

	// Gets the creation date and time of the storage account in UTC.
	// Read Only: true
	CreationTime strfmt.DateTime `json:"creationTime,omitempty"`

	// Gets the custom domain the user assigned to this storage account.
	// Read Only: true
	CustomDomain *CustomDomain `json:"customDomain,omitempty"`

	// Gets the encryption settings on the account. If unspecified, the account is unencrypted.
	// Read Only: true
	Encryption *Encryption `json:"encryption,omitempty"`

	// Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
	// Read Only: true
	LastGeoFailoverTime strfmt.DateTime `json:"lastGeoFailoverTime,omitempty"`

	// Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that Standard_ZRS and Premium_LRS accounts only return the blob endpoint.
	// Read Only: true
	PrimaryEndpoints *Endpoints `json:"primaryEndpoints,omitempty"`

	// Gets the location of the primary data center for the storage account.
	// Read Only: true
	PrimaryLocation string `json:"primaryLocation,omitempty"`

	// Gets the status of the storage account at the time the operation was called.
	// Read Only: true
	ProvisioningState string `json:"provisioningState,omitempty"`

	// Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the secondary location of the storage account. Only available if the SKU name is Standard_RAGRS.
	// Read Only: true
	SecondaryEndpoints *Endpoints `json:"secondaryEndpoints,omitempty"`

	// Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
	// Read Only: true
	SecondaryLocation string `json:"secondaryLocation,omitempty"`

	// Gets the status indicating whether the primary location of the storage account is available or unavailable.
	// Read Only: true
	StatusOfPrimary string `json:"statusOfPrimary,omitempty"`

	// Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS.
	// Read Only: true
	StatusOfSecondary string `json:"statusOfSecondary,omitempty"`

	// Allows https traffic only to storage service if sets to true.
	SupportsHTTPSTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`
}

// Validate validates this storage account properties
func (m *StorageAccountProperties) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessTier(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCustomDomain(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEncryption(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePrimaryEndpoints(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProvisioningState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSecondaryEndpoints(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatusOfPrimary(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatusOfSecondary(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var storageAccountPropertiesTypeAccessTierPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Hot","Cool"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageAccountPropertiesTypeAccessTierPropEnum = append(storageAccountPropertiesTypeAccessTierPropEnum, v)
	}
}

const (
	// StorageAccountPropertiesAccessTierHot captures enum value "Hot"
	StorageAccountPropertiesAccessTierHot string = "Hot"
	// StorageAccountPropertiesAccessTierCool captures enum value "Cool"
	StorageAccountPropertiesAccessTierCool string = "Cool"
)

// prop value enum
func (m *StorageAccountProperties) validateAccessTierEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storageAccountPropertiesTypeAccessTierPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StorageAccountProperties) validateAccessTier(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessTier) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccessTierEnum("accessTier", "body", m.AccessTier); err != nil {
		return err
	}

	return nil
}

func (m *StorageAccountProperties) validateCustomDomain(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomDomain) { // not required
		return nil
	}

	if m.CustomDomain != nil {

		if err := m.CustomDomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customDomain")
			}
			return err
		}
	}

	return nil
}

func (m *StorageAccountProperties) validateEncryption(formats strfmt.Registry) error {

	if swag.IsZero(m.Encryption) { // not required
		return nil
	}

	if m.Encryption != nil {

		if err := m.Encryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption")
			}
			return err
		}
	}

	return nil
}

func (m *StorageAccountProperties) validatePrimaryEndpoints(formats strfmt.Registry) error {

	if swag.IsZero(m.PrimaryEndpoints) { // not required
		return nil
	}

	if m.PrimaryEndpoints != nil {

		if err := m.PrimaryEndpoints.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primaryEndpoints")
			}
			return err
		}
	}

	return nil
}

var storageAccountPropertiesTypeProvisioningStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Creating","ResolvingDNS","Succeeded"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageAccountPropertiesTypeProvisioningStatePropEnum = append(storageAccountPropertiesTypeProvisioningStatePropEnum, v)
	}
}

const (
	// StorageAccountPropertiesProvisioningStateCreating captures enum value "Creating"
	StorageAccountPropertiesProvisioningStateCreating string = "Creating"
	// StorageAccountPropertiesProvisioningStateResolvingDNS captures enum value "ResolvingDNS"
	StorageAccountPropertiesProvisioningStateResolvingDNS string = "ResolvingDNS"
	// StorageAccountPropertiesProvisioningStateSucceeded captures enum value "Succeeded"
	StorageAccountPropertiesProvisioningStateSucceeded string = "Succeeded"
)

// prop value enum
func (m *StorageAccountProperties) validateProvisioningStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storageAccountPropertiesTypeProvisioningStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StorageAccountProperties) validateProvisioningState(formats strfmt.Registry) error {

	if swag.IsZero(m.ProvisioningState) { // not required
		return nil
	}

	// value enum
	if err := m.validateProvisioningStateEnum("provisioningState", "body", m.ProvisioningState); err != nil {
		return err
	}

	return nil
}

func (m *StorageAccountProperties) validateSecondaryEndpoints(formats strfmt.Registry) error {

	if swag.IsZero(m.SecondaryEndpoints) { // not required
		return nil
	}

	if m.SecondaryEndpoints != nil {

		if err := m.SecondaryEndpoints.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secondaryEndpoints")
			}
			return err
		}
	}

	return nil
}

var storageAccountPropertiesTypeStatusOfPrimaryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["available","unavailable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageAccountPropertiesTypeStatusOfPrimaryPropEnum = append(storageAccountPropertiesTypeStatusOfPrimaryPropEnum, v)
	}
}

const (
	// StorageAccountPropertiesStatusOfPrimaryAvailable captures enum value "available"
	StorageAccountPropertiesStatusOfPrimaryAvailable string = "available"
	// StorageAccountPropertiesStatusOfPrimaryUnavailable captures enum value "unavailable"
	StorageAccountPropertiesStatusOfPrimaryUnavailable string = "unavailable"
)

// prop value enum
func (m *StorageAccountProperties) validateStatusOfPrimaryEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storageAccountPropertiesTypeStatusOfPrimaryPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StorageAccountProperties) validateStatusOfPrimary(formats strfmt.Registry) error {

	if swag.IsZero(m.StatusOfPrimary) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusOfPrimaryEnum("statusOfPrimary", "body", m.StatusOfPrimary); err != nil {
		return err
	}

	return nil
}

var storageAccountPropertiesTypeStatusOfSecondaryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["available","unavailable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageAccountPropertiesTypeStatusOfSecondaryPropEnum = append(storageAccountPropertiesTypeStatusOfSecondaryPropEnum, v)
	}
}

const (
	// StorageAccountPropertiesStatusOfSecondaryAvailable captures enum value "available"
	StorageAccountPropertiesStatusOfSecondaryAvailable string = "available"
	// StorageAccountPropertiesStatusOfSecondaryUnavailable captures enum value "unavailable"
	StorageAccountPropertiesStatusOfSecondaryUnavailable string = "unavailable"
)

// prop value enum
func (m *StorageAccountProperties) validateStatusOfSecondaryEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storageAccountPropertiesTypeStatusOfSecondaryPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StorageAccountProperties) validateStatusOfSecondary(formats strfmt.Registry) error {

	if swag.IsZero(m.StatusOfSecondary) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusOfSecondaryEnum("statusOfSecondary", "body", m.StatusOfSecondary); err != nil {
		return err
	}

	return nil
}

package deployments

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new deployments API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for deployments API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeploymentsCancel cancels a currently running template deployment

You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
*/
func (a *Client) DeploymentsCancel(params *DeploymentsCancelParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsCancelNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsCancelParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_Cancel",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsCancelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeploymentsCancelNoContent), nil

}

/*
DeploymentsCheckExistence Checks whether the deployment exists.
*/
func (a *Client) DeploymentsCheckExistence(params *DeploymentsCheckExistenceParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsCheckExistenceNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsCheckExistenceParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_CheckExistence",
		Method:             "HEAD",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsCheckExistenceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeploymentsCheckExistenceNoContent), nil

}

/*
DeploymentsCreateOrUpdate deploys resources to a resource group

You can provide the template and parameters directly in the request or link to JSON files.
*/
func (a *Client) DeploymentsCreateOrUpdate(params *DeploymentsCreateOrUpdateParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsCreateOrUpdateOK, *DeploymentsCreateOrUpdateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsCreateOrUpdateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_CreateOrUpdate",
		Method:             "PUT",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsCreateOrUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeploymentsCreateOrUpdateOK:
		return value, nil, nil
	case *DeploymentsCreateOrUpdateCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeploymentsDelete deletes a deployment from the deployment history

A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
*/
func (a *Client) DeploymentsDelete(params *DeploymentsDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsDeleteAccepted, *DeploymentsDeleteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_Delete",
		Method:             "DELETE",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeploymentsDeleteAccepted:
		return value, nil, nil
	case *DeploymentsDeleteNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeploymentsExportTemplate Exports the template used for specified deployment.
*/
func (a *Client) DeploymentsExportTemplate(params *DeploymentsExportTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsExportTemplateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsExportTemplateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_ExportTemplate",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsExportTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeploymentsExportTemplateOK), nil

}

/*
DeploymentsGet Gets a deployment.
*/
func (a *Client) DeploymentsGet(params *DeploymentsGetParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_Get",
		Method:             "GET",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeploymentsGetOK), nil

}

/*
DeploymentsList Get all the deployments for a resource group.
*/
func (a *Client) DeploymentsList(params *DeploymentsListParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_List",
		Method:             "GET",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeploymentsListOK), nil

}

/*
DeploymentsValidate Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
*/
func (a *Client) DeploymentsValidate(params *DeploymentsValidateParams, authInfo runtime.ClientAuthInfoWriter) (*DeploymentsValidateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeploymentsValidateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Deployments_Validate",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeploymentsValidateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeploymentsValidateOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

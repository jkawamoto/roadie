package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// CloudTask An Azure Batch task.
// swagger:model CloudTask
type CloudTask struct {

	// A locality hint that can be used by the Batch service to select a compute node on which to start the new task.
	AffinityInfo *AffinityInformation `json:"affinityInfo,omitempty"`

	// A list of application packages that the Batch service will deploy to the compute node before running the command line.
	ApplicationPackageReferences []*ApplicationPackageReference `json:"applicationPackageReferences"`

	// The command line of the task.
	//
	// For multi-instance tasks, the command line is executed as the primary task, after the primary task and all subtasks have finished executing the coordination command line. The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment variable expansion. If you want to take advantage of such features, you should invoke the shell in the command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
	CommandLine string `json:"commandLine,omitempty"`

	// The execution constraints that apply to this task.
	Constraints *TaskConstraints `json:"constraints,omitempty"`

	// The creation time of the task.
	CreationTime strfmt.DateTime `json:"creationTime,omitempty"`

	// The tasks that this task depends on.
	//
	// The task will not be scheduled until all depended-on tasks have completed successfully. (If any depended-on tasks fail and exhaust their retry counts, the task will never be scheduled.)
	DependsOn *TaskDependencies `json:"dependsOn,omitempty"`

	// A display name for the task.
	//
	// The display name need not be unique and can contain any Unicode characters up to a maximum length of 1024.
	DisplayName string `json:"displayName,omitempty"`

	// The ETag of the task.
	//
	// This is an opaque string. You can use it to detect whether the task has changed between requests. In particular, you can be pass the ETag when updating a task to specify that your changes should take effect only if nobody else has modified the task in the meantime.
	ETag string `json:"eTag,omitempty"`

	// A list of environment variable settings for the task.
	EnvironmentSettings []*EnvironmentSetting `json:"environmentSettings"`

	// Information about the execution of the task.
	ExecutionInfo *TaskExecutionInformation `json:"executionInfo,omitempty"`

	// How the Batch service should respond when the task completes.
	ExitConditions *ExitConditions `json:"exitConditions,omitempty"`

	// A string that uniquely identifies the task within the job.
	//
	// The ID can contain any combination of alphanumeric characters including hyphens and underscores, and cannot contain more than 64 characters.
	ID string `json:"id,omitempty"`

	// The last modified time of the task.
	LastModified strfmt.DateTime `json:"lastModified,omitempty"`

	// An object that indicates that the task is a multi-instance task, and contains information about how to run the multi-instance task.
	MultiInstanceSettings *MultiInstanceSettings `json:"multiInstanceSettings,omitempty"`

	// Information about the compute node on which the task ran.
	NodeInfo *ComputeNodeInformation `json:"nodeInfo,omitempty"`

	// The previous state of the task.
	//
	// This property is not set if the task is in its initial Active state.
	PreviousState string `json:"previousState,omitempty"`

	// The time at which the task entered its previous state.
	//
	// This property is not set if the task is in its initial Active state.
	PreviousStateTransitionTime strfmt.DateTime `json:"previousStateTransitionTime,omitempty"`

	// A list of files that the Batch service will download to the compute node before running the command line.
	//
	// For multi-instance tasks, the resource files will only be downloaded to the compute node on which the primary task is executed.
	ResourceFiles []*ResourceFile `json:"resourceFiles"`

	// Whether to run the task in elevated mode.
	RunElevated bool `json:"runElevated,omitempty"`

	// The current state of the task.
	State string `json:"state,omitempty"`

	// The time at which the task entered its current state.
	StateTransitionTime strfmt.DateTime `json:"stateTransitionTime,omitempty"`

	// Resource usage statistics for the task.
	Stats *TaskStatistics `json:"stats,omitempty"`

	// The URL of the task.
	URL string `json:"url,omitempty"`
}

// Validate validates this cloud task
func (m *CloudTask) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAffinityInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateApplicationPackageReferences(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateConstraints(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDependsOn(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEnvironmentSettings(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateExecutionInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateExitConditions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMultiInstanceSettings(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNodeInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePreviousState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateResourceFiles(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTask) validateAffinityInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.AffinityInfo) { // not required
		return nil
	}

	if m.AffinityInfo != nil {

		if err := m.AffinityInfo.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *CloudTask) validateApplicationPackageReferences(formats strfmt.Registry) error {

	if swag.IsZero(m.ApplicationPackageReferences) { // not required
		return nil
	}

	for i := 0; i < len(m.ApplicationPackageReferences); i++ {

		if swag.IsZero(m.ApplicationPackageReferences[i]) { // not required
			continue
		}

		if m.ApplicationPackageReferences[i] != nil {

			if err := m.ApplicationPackageReferences[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *CloudTask) validateConstraints(formats strfmt.Registry) error {

	if swag.IsZero(m.Constraints) { // not required
		return nil
	}

	if m.Constraints != nil {

		if err := m.Constraints.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *CloudTask) validateDependsOn(formats strfmt.Registry) error {

	if swag.IsZero(m.DependsOn) { // not required
		return nil
	}

	if m.DependsOn != nil {

		if err := m.DependsOn.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *CloudTask) validateEnvironmentSettings(formats strfmt.Registry) error {

	if swag.IsZero(m.EnvironmentSettings) { // not required
		return nil
	}

	for i := 0; i < len(m.EnvironmentSettings); i++ {

		if swag.IsZero(m.EnvironmentSettings[i]) { // not required
			continue
		}

		if m.EnvironmentSettings[i] != nil {

			if err := m.EnvironmentSettings[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *CloudTask) validateExecutionInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.ExecutionInfo) { // not required
		return nil
	}

	if m.ExecutionInfo != nil {

		if err := m.ExecutionInfo.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *CloudTask) validateExitConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.ExitConditions) { // not required
		return nil
	}

	if m.ExitConditions != nil {

		if err := m.ExitConditions.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *CloudTask) validateMultiInstanceSettings(formats strfmt.Registry) error {

	if swag.IsZero(m.MultiInstanceSettings) { // not required
		return nil
	}

	if m.MultiInstanceSettings != nil {

		if err := m.MultiInstanceSettings.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *CloudTask) validateNodeInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeInfo) { // not required
		return nil
	}

	if m.NodeInfo != nil {

		if err := m.NodeInfo.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

var cloudTaskTypePreviousStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","preparing","running","completed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloudTaskTypePreviousStatePropEnum = append(cloudTaskTypePreviousStatePropEnum, v)
	}
}

const (
	// CloudTaskPreviousStateActive captures enum value "active"
	CloudTaskPreviousStateActive string = "active"
	// CloudTaskPreviousStatePreparing captures enum value "preparing"
	CloudTaskPreviousStatePreparing string = "preparing"
	// CloudTaskPreviousStateRunning captures enum value "running"
	CloudTaskPreviousStateRunning string = "running"
	// CloudTaskPreviousStateCompleted captures enum value "completed"
	CloudTaskPreviousStateCompleted string = "completed"
)

// prop value enum
func (m *CloudTask) validatePreviousStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, cloudTaskTypePreviousStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CloudTask) validatePreviousState(formats strfmt.Registry) error {

	if swag.IsZero(m.PreviousState) { // not required
		return nil
	}

	// value enum
	if err := m.validatePreviousStateEnum("previousState", "body", m.PreviousState); err != nil {
		return err
	}

	return nil
}

func (m *CloudTask) validateResourceFiles(formats strfmt.Registry) error {

	if swag.IsZero(m.ResourceFiles) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceFiles); i++ {

		if swag.IsZero(m.ResourceFiles[i]) { // not required
			continue
		}

		if m.ResourceFiles[i] != nil {

			if err := m.ResourceFiles[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var cloudTaskTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","preparing","running","completed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloudTaskTypeStatePropEnum = append(cloudTaskTypeStatePropEnum, v)
	}
}

const (
	// CloudTaskStateActive captures enum value "active"
	CloudTaskStateActive string = "active"
	// CloudTaskStatePreparing captures enum value "preparing"
	CloudTaskStatePreparing string = "preparing"
	// CloudTaskStateRunning captures enum value "running"
	CloudTaskStateRunning string = "running"
	// CloudTaskStateCompleted captures enum value "completed"
	CloudTaskStateCompleted string = "completed"
)

// prop value enum
func (m *CloudTask) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, cloudTaskTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CloudTask) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *CloudTask) validateStats(formats strfmt.Registry) error {

	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {

		if err := m.Stats.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// JobPreparationTaskExecutionInformation Contains information about the execution of a Job Preparation task on a compute node.
// swagger:model JobPreparationTaskExecutionInformation
type JobPreparationTaskExecutionInformation struct {

	// The time at which the Job Preparation task completed.
	//
	// This property is set only if the task is in the Completed state.
	EndTime strfmt.DateTime `json:"endTime,omitempty"`

	// The exit code of the program specified on the task command line.
	//
	// This parameter is returned only if the task is in the completed state. The exit code for a process reflects the specific convention implemented by the application developer for that process. If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process. Note that the exit code may also be generated by the compute node operating system, such as when a process is forcibly terminated.
	ExitCode int32 `json:"exitCode,omitempty"`

	// The most recent time at which a retry of the Job Preparation task started running.
	//
	// This property is set only if the task was retried (i.e. retryCount is nonzero). If present, this is typically the same as startTime, but may be different if the task has been restarted for reasons other than retry; for example, if the compute node was rebooted during a retry, then the startTime is updated but the lastRetryTime is not.
	LastRetryTime strfmt.DateTime `json:"lastRetryTime,omitempty"`

	// The number of times the task has been retried by the Batch service. Every time the task exits with a non-zero exit code, it is deemed a task failure. The Batch service will retry the task up to the limit specified by the constraints.
	// Required: true
	RetryCount *int32 `json:"retryCount"`

	// The error encountered by the Batch service when starting the task.
	SchedulingError *TaskSchedulingError `json:"schedulingError,omitempty"`

	// The time at which the task started running.
	//
	// Note that every time the task is restarted, this value is updated.
	// Required: true
	StartTime *strfmt.DateTime `json:"startTime"`

	// The current state of the Job Preparation task on the compute node.
	//
	// Possible values are: running – the task is currently running (including retrying). completed – the task has exited with exit code 0, or the task has exhausted its retry limit, or the Batch service was unable to start the task due to scheduling errors
	// Required: true
	State *string `json:"state"`

	// The root directory of the Job Preparation task on the compute node. You can use this path to retrieve files created by the task, such as log files.
	TaskRootDirectory string `json:"taskRootDirectory,omitempty"`

	// The URL to the root directory of the Job Preparation task on the compute node.
	TaskRootDirectoryURL string `json:"taskRootDirectoryUrl,omitempty"`
}

// Validate validates this job preparation task execution information
func (m *JobPreparationTaskExecutionInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRetryCount(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSchedulingError(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *JobPreparationTaskExecutionInformation) validateRetryCount(formats strfmt.Registry) error {

	if err := validate.Required("retryCount", "body", m.RetryCount); err != nil {
		return err
	}

	return nil
}

func (m *JobPreparationTaskExecutionInformation) validateSchedulingError(formats strfmt.Registry) error {

	if swag.IsZero(m.SchedulingError) { // not required
		return nil
	}

	if m.SchedulingError != nil {

		if err := m.SchedulingError.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *JobPreparationTaskExecutionInformation) validateStartTime(formats strfmt.Registry) error {

	if err := validate.Required("startTime", "body", m.StartTime); err != nil {
		return err
	}

	return nil
}

var jobPreparationTaskExecutionInformationTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["running","completed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		jobPreparationTaskExecutionInformationTypeStatePropEnum = append(jobPreparationTaskExecutionInformationTypeStatePropEnum, v)
	}
}

const (
	// JobPreparationTaskExecutionInformationStateRunning captures enum value "running"
	JobPreparationTaskExecutionInformationStateRunning string = "running"
	// JobPreparationTaskExecutionInformationStateCompleted captures enum value "completed"
	JobPreparationTaskExecutionInformationStateCompleted string = "completed"
)

// prop value enum
func (m *JobPreparationTaskExecutionInformation) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, jobPreparationTaskExecutionInformationTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *JobPreparationTaskExecutionInformation) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// TaskInformation Information about a task running on a compute node.
// swagger:model TaskInformation
type TaskInformation struct {

	// Information about the execution of the task.
	ExecutionInfo *TaskExecutionInformation `json:"executionInfo,omitempty"`

	// The ID of the job to which the task belongs.
	JobID string `json:"jobId,omitempty"`

	// The ID of the subtask if the task is a multi-instance task.
	SubtaskID int32 `json:"subtaskId,omitempty"`

	// The ID of the task.
	TaskID string `json:"taskId,omitempty"`

	// The current state of the task.
	// Required: true
	TaskState *string `json:"taskState"`

	// The URL of the task.
	TaskURL string `json:"taskUrl,omitempty"`
}

// Validate validates this task information
func (m *TaskInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExecutionInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTaskState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskInformation) validateExecutionInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.ExecutionInfo) { // not required
		return nil
	}

	if m.ExecutionInfo != nil {

		if err := m.ExecutionInfo.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

var taskInformationTypeTaskStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","preparing","running","completed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taskInformationTypeTaskStatePropEnum = append(taskInformationTypeTaskStatePropEnum, v)
	}
}

const (
	// TaskInformationTaskStateActive captures enum value "active"
	TaskInformationTaskStateActive string = "active"
	// TaskInformationTaskStatePreparing captures enum value "preparing"
	TaskInformationTaskStatePreparing string = "preparing"
	// TaskInformationTaskStateRunning captures enum value "running"
	TaskInformationTaskStateRunning string = "running"
	// TaskInformationTaskStateCompleted captures enum value "completed"
	TaskInformationTaskStateCompleted string = "completed"
)

// prop value enum
func (m *TaskInformation) validateTaskStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, taskInformationTypeTaskStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TaskInformation) validateTaskState(formats strfmt.Registry) error {

	if err := validate.Required("taskState", "body", m.TaskState); err != nil {
		return err
	}

	// value enum
	if err := m.validateTaskStateEnum("taskState", "body", *m.TaskState); err != nil {
		return err
	}

	return nil
}

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// CertificateAddParameter A certificate that can be installed on compute nodes and can be used to authenticate operations on the machine.
// swagger:model CertificateAddParameter
type CertificateAddParameter struct {

	// The format of the certificate data.
	CertificateFormat string `json:"certificateFormat,omitempty"`

	// The base64-encoded contents of the certificate. The maximum size is 10KB.
	// Required: true
	Data *string `json:"data"`

	// The password to access the certificate's private key.
	//
	// This is required if the certificate format is pfx. It should be omitted if the certificate format is cer.
	Password string `json:"password,omitempty"`

	// The X.509 thumbprint of the certificate. This is a sequence of up to 40 hex digits (it may include spaces but these are removed).
	// Required: true
	Thumbprint *string `json:"thumbprint"`

	// The algorithm used to derive the thumbprint. This must be sha1.
	// Required: true
	ThumbprintAlgorithm *string `json:"thumbprintAlgorithm"`
}

// Validate validates this certificate add parameter
func (m *CertificateAddParameter) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCertificateFormat(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateData(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateThumbprint(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateThumbprintAlgorithm(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var certificateAddParameterTypeCertificateFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pfx","cer","unmapped"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		certificateAddParameterTypeCertificateFormatPropEnum = append(certificateAddParameterTypeCertificateFormatPropEnum, v)
	}
}

const (
	// CertificateAddParameterCertificateFormatPfx captures enum value "pfx"
	CertificateAddParameterCertificateFormatPfx string = "pfx"
	// CertificateAddParameterCertificateFormatCer captures enum value "cer"
	CertificateAddParameterCertificateFormatCer string = "cer"
	// CertificateAddParameterCertificateFormatUnmapped captures enum value "unmapped"
	CertificateAddParameterCertificateFormatUnmapped string = "unmapped"
)

// prop value enum
func (m *CertificateAddParameter) validateCertificateFormatEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, certificateAddParameterTypeCertificateFormatPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *CertificateAddParameter) validateCertificateFormat(formats strfmt.Registry) error {

	if swag.IsZero(m.CertificateFormat) { // not required
		return nil
	}

	// value enum
	if err := m.validateCertificateFormatEnum("certificateFormat", "body", m.CertificateFormat); err != nil {
		return err
	}

	return nil
}

func (m *CertificateAddParameter) validateData(formats strfmt.Registry) error {

	if err := validate.Required("data", "body", m.Data); err != nil {
		return err
	}

	return nil
}

func (m *CertificateAddParameter) validateThumbprint(formats strfmt.Registry) error {

	if err := validate.Required("thumbprint", "body", m.Thumbprint); err != nil {
		return err
	}

	return nil
}

func (m *CertificateAddParameter) validateThumbprintAlgorithm(formats strfmt.Registry) error {

	if err := validate.Required("thumbprintAlgorithm", "body", m.ThumbprintAlgorithm); err != nil {
		return err
	}

	return nil
}

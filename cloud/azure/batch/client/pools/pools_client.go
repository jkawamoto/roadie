package pools

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new pools API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for pools API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
PoolAdd adds a pool to the specified account

When naming pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers.
*/
func (a *Client) PoolAdd(params *PoolAddParams) (*PoolAddCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolAddParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_Add",
		Method:             "POST",
		PathPattern:        "/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolAddReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolAddCreated), nil

}

/*
PoolDelete deletes a pool from the specified account

When you request that a pool be deleted, the following actions occur: the pool state is set to deleting; any ongoing resize operation on the pool are stopped; the Batch service starts resizing the pool to zero nodes; any tasks running on existing nodes are terminated and requeued (as if a resize pool operation had been requested with the default requeue option); finally, the pool is removed from the system. Because running tasks are requeued, the user can rerun these tasks by updating their job to target a different pool. The tasks can then run on the new pool. If you want to override the requeue behavior, then you should call resize pool explicitly to shrink the pool to zero size before deleting the pool. If you call an Update, Patch or Delete API on a pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted.
*/
func (a *Client) PoolDelete(params *PoolDeleteParams) (*PoolDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_Delete",
		Method:             "DELETE",
		PathPattern:        "/pools/{poolId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolDeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolDeleteAccepted), nil

}

/*
PoolDisableAutoScale disables automatic scaling for a pool
*/
func (a *Client) PoolDisableAutoScale(params *PoolDisableAutoScaleParams) (*PoolDisableAutoScaleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolDisableAutoScaleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_DisableAutoScale",
		Method:             "POST",
		PathPattern:        "/pools/{poolId}/disableautoscale",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolDisableAutoScaleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolDisableAutoScaleOK), nil

}

/*
PoolEnableAutoScale enables automatic scaling for a pool

You cannot enable automatic scaling on a pool if a resize operation is in progress on the pool. If automatic scaling of the pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same pool more than once every 30 seconds.
*/
func (a *Client) PoolEnableAutoScale(params *PoolEnableAutoScaleParams) (*PoolEnableAutoScaleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolEnableAutoScaleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_EnableAutoScale",
		Method:             "POST",
		PathPattern:        "/pools/{poolId}/enableautoscale",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolEnableAutoScaleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolEnableAutoScaleOK), nil

}

/*
PoolEvaluateAutoScale gets the result of evaluating an automatic scaling formula on the pool

This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the pool.
*/
func (a *Client) PoolEvaluateAutoScale(params *PoolEvaluateAutoScaleParams) (*PoolEvaluateAutoScaleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolEvaluateAutoScaleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_EvaluateAutoScale",
		Method:             "POST",
		PathPattern:        "/pools/{poolId}/evaluateautoscale",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolEvaluateAutoScaleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolEvaluateAutoScaleOK), nil

}

/*
PoolExists Gets basic properties of a pool.
*/
func (a *Client) PoolExists(params *PoolExistsParams) (*PoolExistsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolExistsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_Exists",
		Method:             "HEAD",
		PathPattern:        "/pools/{poolId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolExistsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolExistsOK), nil

}

/*
PoolGet Gets information about the specified pool.
*/
func (a *Client) PoolGet(params *PoolGetParams) (*PoolGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_Get",
		Method:             "GET",
		PathPattern:        "/pools/{poolId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolGetOK), nil

}

/*
PoolGetAllPoolsLifetimeStatistics gets lifetime summary statistics for all of the pools in the specified account

Statistics are aggregated across all pools that have ever existed in the account, from account creation to the last update time of the statistics.
*/
func (a *Client) PoolGetAllPoolsLifetimeStatistics(params *PoolGetAllPoolsLifetimeStatisticsParams) (*PoolGetAllPoolsLifetimeStatisticsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolGetAllPoolsLifetimeStatisticsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_GetAllPoolsLifetimeStatistics",
		Method:             "GET",
		PathPattern:        "/lifetimepoolstats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolGetAllPoolsLifetimeStatisticsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolGetAllPoolsLifetimeStatisticsOK), nil

}

/*
PoolList lists all of the pools in the specified account
*/
func (a *Client) PoolList(params *PoolListParams) (*PoolListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_List",
		Method:             "GET",
		PathPattern:        "/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolListOK), nil

}

/*
PoolListPoolUsageMetrics lists the usage metrics aggregated by pool across individual time intervals for the specified account

If you do not specify a $filter clause including a poolId, the response includes all pools that existed in the account in the time range of the returned aggregation intervals.
*/
func (a *Client) PoolListPoolUsageMetrics(params *PoolListPoolUsageMetricsParams) (*PoolListPoolUsageMetricsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolListPoolUsageMetricsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_ListPoolUsageMetrics",
		Method:             "GET",
		PathPattern:        "/poolusagemetrics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolListPoolUsageMetricsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolListPoolUsageMetricsOK), nil

}

/*
PoolPatch updates the properties of the specified pool

This only replaces the pool properties specified in the request. For example, if the pool has a start task associated with it, and a request does not specify a start task element, then the pool keeps the existing start task.
*/
func (a *Client) PoolPatch(params *PoolPatchParams) (*PoolPatchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolPatchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_Patch",
		Method:             "PATCH",
		PathPattern:        "/pools/{poolId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolPatchReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolPatchOK), nil

}

/*
PoolResize changes the number of compute nodes that are assigned to a pool

You can only resize a pool when its allocation state is steady. If the pool is already resizing, the request fails with status code 409. When you resize a pool, the pool's allocation state changes from steady to resizing. You cannot resize pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a pool downwards, the Batch service chooses which nodes to remove. To remove specific nodes, use the pool remove nodes API instead.
*/
func (a *Client) PoolResize(params *PoolResizeParams) (*PoolResizeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolResizeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_Resize",
		Method:             "POST",
		PathPattern:        "/pools/{poolId}/resize",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolResizeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolResizeAccepted), nil

}

/*
PoolStopResize stops an ongoing resize operation on the pool

This does not restore the pool to its previous state before the resize operation: it only stops any further changes being made, and the pool maintains its current state. A resize operation need not be an explicit resize pool request; this API can also be used to halt the initial sizing of the pool when it is created.
*/
func (a *Client) PoolStopResize(params *PoolStopResizeParams) (*PoolStopResizeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolStopResizeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_StopResize",
		Method:             "POST",
		PathPattern:        "/pools/{poolId}/stopresize",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolStopResizeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolStopResizeAccepted), nil

}

/*
PoolUpdateProperties updates the properties of the specified pool

This fully replaces all the updateable properties of the pool. For example, if the pool has a start task associated with it and if start task is not specified with this request, then the Batch service will remove the existing start task.
*/
func (a *Client) PoolUpdateProperties(params *PoolUpdatePropertiesParams) (*PoolUpdatePropertiesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolUpdatePropertiesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_UpdateProperties",
		Method:             "POST",
		PathPattern:        "/pools/{poolId}/updateproperties",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolUpdatePropertiesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolUpdatePropertiesNoContent), nil

}

/*
PoolUpgradeOS upgrades the operating system of the specified pool

During an upgrade, the Batch service upgrades each compute node in the pool. When a compute node is chosen for upgrade, any tasks running on that node are removed from the node and returned to the queue to be rerun later (or on a different compute node). The node will be unavailable until the upgrade is complete. This operation results in temporarily reduced pool capacity as nodes are taken out of service to be upgraded. Although the Batch service tries to avoid upgrading all compute nodes at the same time, it does not guarantee to do this (particularly on small pools); therefore, the pool may be temporarily unavailable to run tasks. When this operation runs, the pool state changes to upgrading. When all compute nodes have finished upgrading, the pool state returns to active.
*/
func (a *Client) PoolUpgradeOS(params *PoolUpgradeOSParams) (*PoolUpgradeOSAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoolUpgradeOSParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Pool_UpgradeOS",
		Method:             "POST",
		PathPattern:        "/pools/{poolId}/upgradeos",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoolUpgradeOSReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PoolUpgradeOSAccepted), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

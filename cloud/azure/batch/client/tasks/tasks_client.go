package tasks

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new tasks API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for tasks API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
TaskAdd adds a task to the specified job
*/
func (a *Client) TaskAdd(params *TaskAddParams) (*TaskAddCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskAddParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_Add",
		Method:             "POST",
		PathPattern:        "/jobs/{jobId}/tasks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskAddReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskAddCreated), nil

}

/*
TaskAddCollection adds a collection of tasks to the specified job

Note that each task must have a unique ID. The Batch service may not return the results for each task in the same order the tasks were submitted in this request. If the server times out or the connection is closed during the request, the request may have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the same task ids during a retry so that if the prior operation succeeded, the retry will not create extra tasks unexpectedly.
*/
func (a *Client) TaskAddCollection(params *TaskAddCollectionParams) (*TaskAddCollectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskAddCollectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_AddCollection",
		Method:             "POST",
		PathPattern:        "/jobs/{jobId}/addtaskcollection",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskAddCollectionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskAddCollectionOK), nil

}

/*
TaskDelete deletes a task from the specified job

When a task is deleted, all of the files in its directory on the compute node where it ran are also deleted (regardless of the retention time). For multi-instance tasks, the delete task operation applies synchronously to the primary task; subtasks and their files are then deleted asynchronously in the background.
*/
func (a *Client) TaskDelete(params *TaskDeleteParams) (*TaskDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_Delete",
		Method:             "DELETE",
		PathPattern:        "/jobs/{jobId}/tasks/{taskId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskDeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskDeleteOK), nil

}

/*
TaskGet gets information about the specified task

For multi-instance tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary task. Use the list subtasks API to retrieve information about subtasks.
*/
func (a *Client) TaskGet(params *TaskGetParams) (*TaskGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_Get",
		Method:             "GET",
		PathPattern:        "/jobs/{jobId}/tasks/{taskId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskGetOK), nil

}

/*
TaskList lists all of the tasks that are associated with the specified job

For multi-instance tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary task. Use the list subtasks API to retrieve information about subtasks.
*/
func (a *Client) TaskList(params *TaskListParams) (*TaskListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_List",
		Method:             "GET",
		PathPattern:        "/jobs/{jobId}/tasks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskListOK), nil

}

/*
TaskListSubtasks lists all of the subtasks that are associated with the specified multi instance task

If the task is not a multi-instance task then this returns an empty collection.
*/
func (a *Client) TaskListSubtasks(params *TaskListSubtasksParams) (*TaskListSubtasksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskListSubtasksParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_ListSubtasks",
		Method:             "GET",
		PathPattern:        "/jobs/{jobId}/tasks/{taskId}/subtasksinfo",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskListSubtasksReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskListSubtasksOK), nil

}

/*
TaskReactivate reactivates the specified task

Reactivation makes a task eligible to be retried again up to its maximum retry count. The task's state is changed to active. As the task is no longer in the completed state, any previous exit code or scheduling error is no longer available after reactivation. This will fail for tasks that are not completed or that previously completed successfully (with an exit code of 0). Additionally, this will fail if the job has completed (or is terminating or deleting).
*/
func (a *Client) TaskReactivate(params *TaskReactivateParams) (*TaskReactivateNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskReactivateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_Reactivate",
		Method:             "POST",
		PathPattern:        "/jobs/{jobId}/tasks/{taskId}/reactivate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskReactivateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskReactivateNoContent), nil

}

/*
TaskTerminate terminates the specified task

When the task has been terminated, it moves to the completed state. For multi-instance tasks, the terminate task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the background.
*/
func (a *Client) TaskTerminate(params *TaskTerminateParams) (*TaskTerminateNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskTerminateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_Terminate",
		Method:             "POST",
		PathPattern:        "/jobs/{jobId}/tasks/{taskId}/terminate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskTerminateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskTerminateNoContent), nil

}

/*
TaskUpdate Updates the properties of the specified task.
*/
func (a *Client) TaskUpdate(params *TaskUpdateParams) (*TaskUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTaskUpdateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Task_Update",
		Method:             "PUT",
		PathPattern:        "/jobs/{jobId}/tasks/{taskId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json; odata=minimalmetadata"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TaskUpdateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TaskUpdateOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

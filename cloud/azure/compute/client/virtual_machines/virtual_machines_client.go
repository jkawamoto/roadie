package virtual_machines

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new virtual machines API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for virtual machines API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
VirtualMachinesCapture Captures the VM by copying virtual hard disks of the VM and outputs a template that can be used to create similar VMs.
*/
func (a *Client) VirtualMachinesCapture(params *VirtualMachinesCaptureParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesCaptureOK, *VirtualMachinesCaptureAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesCaptureParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Capture",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/capture",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesCaptureReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesCaptureOK:
		return value, nil, nil
	case *VirtualMachinesCaptureAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
VirtualMachinesConvertToManagedDisks Converts virtual machine disks from blob-based to managed disks. Virtual machine must be stop-deallocated before invoking this operation.
*/
func (a *Client) VirtualMachinesConvertToManagedDisks(params *VirtualMachinesConvertToManagedDisksParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesConvertToManagedDisksOK, *VirtualMachinesConvertToManagedDisksAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesConvertToManagedDisksParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_ConvertToManagedDisks",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/convertToManagedDisks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesConvertToManagedDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesConvertToManagedDisksOK:
		return value, nil, nil
	case *VirtualMachinesConvertToManagedDisksAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
VirtualMachinesCreateOrUpdate The operation to create or update a virtual machine.
*/
func (a *Client) VirtualMachinesCreateOrUpdate(params *VirtualMachinesCreateOrUpdateParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesCreateOrUpdateOK, *VirtualMachinesCreateOrUpdateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesCreateOrUpdateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_CreateOrUpdate",
		Method:             "PUT",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesCreateOrUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesCreateOrUpdateOK:
		return value, nil, nil
	case *VirtualMachinesCreateOrUpdateCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
VirtualMachinesDeallocate Shuts down the virtual machine and releases the compute resources. You are not billed for the compute resources that this virtual machine uses.
*/
func (a *Client) VirtualMachinesDeallocate(params *VirtualMachinesDeallocateParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesDeallocateOK, *VirtualMachinesDeallocateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesDeallocateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Deallocate",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/deallocate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesDeallocateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesDeallocateOK:
		return value, nil, nil
	case *VirtualMachinesDeallocateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
VirtualMachinesDelete The operation to delete a virtual machine.
*/
func (a *Client) VirtualMachinesDelete(params *VirtualMachinesDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesDeleteOK, *VirtualMachinesDeleteAccepted, *VirtualMachinesDeleteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Delete",
		Method:             "DELETE",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesDeleteOK:
		return value, nil, nil, nil
	case *VirtualMachinesDeleteAccepted:
		return nil, value, nil, nil
	case *VirtualMachinesDeleteNoContent:
		return nil, nil, value, nil
	}
	return nil, nil, nil, nil

}

/*
VirtualMachinesGeneralize Sets the state of the virtual machine to generalized.
*/
func (a *Client) VirtualMachinesGeneralize(params *VirtualMachinesGeneralizeParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesGeneralizeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesGeneralizeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Generalize",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/generalize",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesGeneralizeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*VirtualMachinesGeneralizeOK), nil

}

/*
VirtualMachinesGet Retrieves information about the model view or the instance view of a virtual machine.
*/
func (a *Client) VirtualMachinesGet(params *VirtualMachinesGetParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Get",
		Method:             "GET",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*VirtualMachinesGetOK), nil

}

/*
VirtualMachinesList Lists all of the virtual machines in the specified resource group. Use the nextLink property in the response to get the next page of virtual machines.
*/
func (a *Client) VirtualMachinesList(params *VirtualMachinesListParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_List",
		Method:             "GET",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*VirtualMachinesListOK), nil

}

/*
VirtualMachinesListAll Lists all of the virtual machines in the specified subscription. Use the nextLink property in the response to get the next page of virtual machines.
*/
func (a *Client) VirtualMachinesListAll(params *VirtualMachinesListAllParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesListAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesListAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_ListAll",
		Method:             "GET",
		PathPattern:        "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/virtualMachines",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesListAllReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*VirtualMachinesListAllOK), nil

}

/*
VirtualMachinesListAvailableSizes Lists all available virtual machine sizes to which the specified virtual machine can be resized.
*/
func (a *Client) VirtualMachinesListAvailableSizes(params *VirtualMachinesListAvailableSizesParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesListAvailableSizesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesListAvailableSizesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_ListAvailableSizes",
		Method:             "GET",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/vmSizes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesListAvailableSizesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*VirtualMachinesListAvailableSizesOK), nil

}

/*
VirtualMachinesPowerOff The operation to power off (stop) a virtual machine. The virtual machine can be restarted with the same provisioned resources. You are still charged for this virtual machine.
*/
func (a *Client) VirtualMachinesPowerOff(params *VirtualMachinesPowerOffParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesPowerOffOK, *VirtualMachinesPowerOffAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesPowerOffParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_PowerOff",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/powerOff",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesPowerOffReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesPowerOffOK:
		return value, nil, nil
	case *VirtualMachinesPowerOffAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
VirtualMachinesRedeploy The operation to redeploy a virtual machine.
*/
func (a *Client) VirtualMachinesRedeploy(params *VirtualMachinesRedeployParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesRedeployOK, *VirtualMachinesRedeployAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesRedeployParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Redeploy",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/redeploy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesRedeployReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesRedeployOK:
		return value, nil, nil
	case *VirtualMachinesRedeployAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
VirtualMachinesRestart The operation to restart a virtual machine.
*/
func (a *Client) VirtualMachinesRestart(params *VirtualMachinesRestartParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesRestartOK, *VirtualMachinesRestartAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesRestartParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Restart",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/restart",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesRestartReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesRestartOK:
		return value, nil, nil
	case *VirtualMachinesRestartAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
VirtualMachinesStart The operation to start a virtual machine.
*/
func (a *Client) VirtualMachinesStart(params *VirtualMachinesStartParams, authInfo runtime.ClientAuthInfoWriter) (*VirtualMachinesStartOK, *VirtualMachinesStartAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVirtualMachinesStartParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "VirtualMachines_Start",
		Method:             "POST",
		PathPattern:        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/start",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VirtualMachinesStartReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *VirtualMachinesStartOK:
		return value, nil, nil
	case *VirtualMachinesStartAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
